 <!DOCTYPE html>
<html>
<!--
✪I need to obsolete the canvas builders in ops, I have moved them to HMI where I intend to use them now.
✪I will be obsoleting the list button entries and leaves and from now on will be making a div 'card' for each list entry with no expansion leaf.
✪I will add a column to each entry list canvas that will allow a constant button option for 'place' and 'stamp' aimed clearly between each list entry.
✪Make the lists and service cart add/remove items in real-time as the variables are altered.
✪There should be functions that will adjust some of the lists to ensure that they reflect the objects that they represent.
✪Make the data-placement of the canvas div elements obsolete with a specific for open and close. I have already made the CSS classes to handle this.
✪Make a drawer system for list entries ✪Make a Cart for temp holding of list items.
✪Update the CSS and make the look of things more easily defined. There should be a light and a dark version of your theme(s).
This would have compounding classes for the canvases. A class for color, another for shape and placement.
Some of these divs I will create will have a backing to prevent click-through to background elements.
✪I should make a new input proxy that is more flexible and is built like other more recent interfaces I am making. It is old and outdated.
✪Make something that will only delete from the DOM if it is a third-level list and something else that will tell if a DOM should be made or opened if it already exists. This will speed up the DOM.
Notepad++ Shortcuts
Notepad++ doesn't remember the style shortcuts. To assign them, select the text below and use shortcut ctrl+alt+shift+[number]. Symbols disrupt the Notepad++ commands.
CTRL + 1							CTRL + 2							CTRL + 3							CTRL + 4							CTRL + 5
Main Objects						Unused								Unused								Testing								Prime Groups
//#:Token-OBJECT				//#:Token-TEST					Token-Unused					Token-Unused					//#:Token-PRIME

DOCUMENT-HEAD
//#:PRIME
-->

























<head>
	<Title>Afthairetos Hosting Web App</Title> 
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#96c300">
	<meta http-equiv="ScreenOrientation" content="autoRotate:disabled">
	 <!--This is the test-->
    <!--<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">-->
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
	
	<script type="text/javascript" src="jquery-3.6.0.js"></script> 
	<!--CSS-STYLE-->
	<style>
		
		:root{
			--backColor1:#000000;
			--backColor2:#000000;
			--fontColor1:#e7e7e7;
			--fontColor2:#96c300;
			--fontColor3:#ffab40;
		}
		


		
		.disable-select {
			 user-select: none; /* supported by Chrome and Opera */
			 -webkit-user-select: none; /* Safari */
			 -khtml-user-select: none; /* Konqueror HTML */
			 -moz-user-select: none; /* Firefox */
			 -ms-user-select: none; /* Internet Explorer/Edge */
		}
		
		* {
			color: var(--fontColor1);
			font-size: 1.045em;
			text-shadow: 10px 10px 10px #00000099;
			
		}
		html {
			height: 100%;
		}
		
		body {
			text-align: center;
			font-family: Arial;
			background-attachment: fixed;
			background-color: DarkGrey; /* For browsers that do not support gradients */
			background-image: linear-gradient(DarkGrey, Black);
			background-position: center;
			/*background-image: linear-gradient(rgba(0, 0, 0, 0.75),rgba(0, 0, 0, 1)) , url('https://github.com/stevo82930/Repository/blob/main/White%20Texture%20One.jpg?raw=true');*/
			background-image: linear-gradient(rgba(0, 0, 0, 0),rgba(0, 0, 0, 0.75)) , url('White Texture One.jpg');
			
		}
		
		/* TEXT CONTROL STYLES*/
		
		myTitles {/*This is used to highlight words in a text.*/
			color: var(--fontColor2);
			font-size: 1em;
			font-weight: bold;
			text-shadow: 2px 2px 10px #00000099;
		}
		
		h1 {
			text-align: center;
			color: var(--fontColor2);
			font-size: 2em;
			font-weight: bold;
			text-shadow: 2px 2px 10px #00000099;
			padding: 5px;
		}
		
		h2 {
			<--text-align: center;/-->
			color: var(--fontColor2);
			font-size: 1em;
			font-weight: bold;
			text-shadow: 2px 2px 10px #00000099;
			padding: 5px;
		}
		
		mark {
			color: var(--fontColor3);
			background-color: #ffffff00;
		}
		
				
		.italicized  {
			font-style: italic;
		}
		
		.bolden {
			font-weight: bold;
		}
		
		.shrinkText {
			font-size: 0.6em;
		}
		
		.lightText {
			/*color: #ffffff99;*/
			/*filter: invert(100%);*/
			filter: brightness(-50%);
			filter: contrast(180%);
		}
		
		.darkText {
			/*color: #ffffff99;*/
			/*filter: invert(100%);*/
			filter: brightness(40%);
		}
		
		.darkerShadow {
			text-shadow: 100px, 100px;
		}
		
		hr.small {
			margin-left:40%;
			margin-right:40%;
			margin-top:2px;
			margin-bottom:2px;
		}
		
		/* STYLES FOR THE VARIOUS DRAWERS */
		
		
		.inputCanvas {
			height: 0%;
			width: 100%;
			position: fixed;
			z-index: 5;
			top: 0;
			left: 0;
			background-color: #000000cc;
			overflow-y: hidden; 
			transition: 0.5s;
			text-align:center;
		}
		
		div.detailsCanvas {
			height: 0%;
			width: 100%;
			position: fixed;
			z-index: 3;
			top: 0;
			left: 0;
			background-color: #000000cc;
			overflow-y: auto; 
			transition: 0.5s;
			text-align:center;
		}
		
		div.listCanvas {
			height: 100%;
			width: 0%;
			position: fixed;
			max-width: 400px;
			margin: auto;
			z-index: 2;
			top: 0;
			right: 0;
			background-color: #ffffffcc;
			overflow-y: auto; 
			transition: 0.25s;
			text-align: left;
		}
		
		div.leftListCanvas {
			height: 100%;
			width: 0%;
			position: fixed;
			max-width: 400px;
			margin: auto;
			z-index: 2;
			top: 0;
			left: 0;
			background-color: #ffffffcc;
			overflow-y: auto; 
			transition: 0.25s;
			text-align: right;
		}
		
		div.bottomTabCanvas {
			height: 0%;
			width: 90%;
			position: fixed;
			margin: auto;
			left: 0; 
			bottom: 0; 
			right: 0;
			max-height: 60%;
			z-index: 2;
			border-radius: 30px 30px 0px 0px;
			background-color: #ffffffcc;
			overflow-y: auto; 
			transition: 0.25s;
			text-align: center;
		}
		
		div.topTabCanvas {
			height: 0%;
			width: 90%;
			position: fixed;
			margin: auto;
			left: 0; 
			top: 0; 
			right: 0;
			max-height: 60%;
			z-index: 2;
			border-radius: 30px 30px 0px 0px;
			background-color: #ffffffcc;
			overflow-y: auto; 
			transition: 0.25s;
			text-align: center;
		}
		
		div.middleTabCanvas {
			height: 0%;
			width: 90%;
			position: fixed;
			margin: auto;
			top: 0;
			left: 0; 
			bottom: 0; 
			right: 0;
			max-height: 90%;
			max-width: 90%;
			z-index: 2;
			border-radius: 30px;
			background-color: #ffffffcc;
			overflow-y: auto; 
			transition: 0.25s;
			text-align: center;
		}
		
		
		div.middleTabGlassCanvas {
			height: 0%;
			width: 90%;
			position: fixed;
			margin: auto;
			top: 0;
			left: 0; 
			bottom: 0; 
			right: 0;
			max-height: 90%;
			max-width: 90%;
			z-index: 2;
			border-radius: 30px;
			border-top: 3px solid #95959580;
			border-left: 3px solid #95959550;
			border-bottom: 3px solid #05050580;
			background-color: #55555500;
			backdrop-filter: blur(8px);
			transition: 0.25s;
			overflow-y: hidden;
			text-align: center;
		}
		
		div.serviceCartCanvas {
			position: absolute;
			z-index: 20;
			height: 0%;
			width: 90%;
			margin: auto;
			left: 0; 
			bottom: 0; 
			right: 0;
			max-height: 60%;
			border-radius: 30px 30px 0px 0px;
			background-color: #ffffffcc;
			transition: 0.25s;
			overflow-y: hidden;
			text-align: center;
		}
		
		.inputCanvas input {
			color: var(--fontColor3);
			background-color: #00000000;
			width:95%;
			height:2.5em;
        	font-size:1em;
			
			text-align: center;
            border: none;
			text-shadow: 2px 2px 5px black;
            border-radius: 8px;
		}
		
		div.contextLeaf {
			display: inline-block;
			overflow: visible;
			background-color: #00000000;
			padding-top: 12px;
			height: 40px;
			width: 100%;
			text-align: right;
		}
		
		div.contextLeafLine {
			display: inline-block;
			overflow: hidden;
			background-color: white;
			height: 100%;
			width: 200px;
			text-align: right;
			box-shadow:
			-200px 0px white,
			-400px 0px white,
			-600px 0px white,
			-800px 0px white,
			-1000px 0px white,
			-1200px 0px white,
			-1400px 0px white,
			-1600px 0px white,
			-1800px 0px white,
			-2000px 0px white,
			-2200px 0px white,
			-2400px 0px white,
			-2600px 0px white,
			-2800px 0px white;
		}
		
		div.contextLeafTarget {
			display: inline-block;
			overflow: hidden;
			background-color: #00000000;
			height: 100%;
			width: 175px;
			text-align: right;
		}
		
		
		.delayshort {
			transition-delay: 0.5s;
		}
		
		div.transformed-state-test {
			transform: rotate(270deg);
			background-color: blue;
			color: yellow;
			font-size: 12px;
			transition-property: background-color, font-size, transform, color;
			transition-timing-function: ease-in-out;
			transition-duration: 3s;
		}
		
		div.openVertically {
			height: 100%;
			width: 100%;
			transition-duration: 0.2s;
			transition-property: height;
		}
		
		div.untuckServiceCart {
			height: 100%;
			transition-duration: 0.2s;
			transition-property: height;
		}
		
		div.openHorizontally {
			height: 100%;
			width: 100%;
			transition-duration: 0.2s;
			transition-property: width;
		}
		
		div.closeVertically {
			transition: revert;
			overflow: hidden;
			height: 0%;
			width: 100%;
			transition-duration: 0.2s;
			transition-property: height;
		}
		
		div.tuckVertically {
			overflow: hidden;
			height: 90px;
			transition-duration: 0.2s;
			transition-property: height;
		}
		
		div.tuckHorizontally {
			overflow: hidden;
			width: 90px;
			transition-duration: 0.2s;
			transition-property: width;
		}
		
		div.closeHorizontally {
			overflow: hidden;
			height: 100%;
			width: 0%;
			transition-duration: 0.2s;
			transition-property: width;
		}
		
		div.innerScroll {
			overflow-y: auto;
		}
		
		div + hr {
			border: 3px solid white;
			margin-top: -6px;
		}
		
		/* 
		//#:PRIME
		SMALLER DIV ELEMEMTS FOR POSITIONING
		*/
		
		.arrow-up {
			display: inline-block;
			margin-left: -20;
			width: 0; 
			height: 0; 
			border-left: 30px solid transparent;
			border-right: 30px solid transparent;

			border-bottom: 30px solid black;
		}
		
		br.inlandscape {
			display:block;
		}
		
		div.triplet {
			overflow: visible;
			height: 30%;
			width: 100%;
			text-align: center;
		}
		
		div.stabilizer {
			display: inline-block;
			height: 100%;
			width: 30%;
			margin: 0;
			padding: 0; 
			/*padding for buttons in the input controller*/
			text-align: center;
		}
		
		div.squareDiv {
			aspect-ratio : 1 / 1;
			width: 90%;
			max-width: 300px;
			margin: auto;
			text-align: center;
			display: inline-block;
		}
		
		.card {
			max-width: 500px;
			margin: auto;
			background-color: #55555500;
			margin:10px;
		}
		
		.cardHolder {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			background-color: #55555500;
			justify-content: center;
		}
		
		/* MY BEAUTIFUL BUTTONS */
		
		button {
        	text-align: center;
			border: none;
			background-color: #00000000;
			border-radius: 48%;
			padding-left: 20px;
			padding-right: 20px;
		}
		
		
		button.token {
			border-radius: 10%;
			padding-left: 5px;
			padding-right: 10px;
			
		}
		
		button.listitem {
			border-radius: 5%;
			padding-left: 5px;
			padding: 10px;
		}
		
		button.spaced {
			border-bottom: 20px;
		}
		
		button.closeBTN {
			margin-bottom: 30px;
		}
		
		button.onCanvas {
			color: var(--fontColor2);
			text-shadow: 2px 2px 5px #000000;
		}
		
		button:disabled,
		button[disabled]{
			color:#99999920;
			text-shadow: none;
		}
		
		button:active {
			transform: translateY(7%);
			box-shadow: inset 8px 6px 10px rgba(0,0,0,0.17), inset -8px -8px 4px #ffffff17;
			text-shadow: 1px 1px 5px #999999;
		}
		
		/* SPACIFIC STYLES */
		
		#description {
			padding: 0px 20px ;
			font-size: 1em;
			color: white;
			text-shadow: none;
		}
		
		#controllerCanvas {
			max-width:1000px;
			max-height:400px;
			overflow:hidden;
		}
		
		#topleftcontroller {
			float: left;
		}
		
		#bottrightcontroller {
			float: right;
		}
		
		#midcontroller {
			line-height: 100px;
			display: inline-block;
			vertical-align: middle;
			text-align: center;
		}
		
		/* FLUXUATION */
		
		@media screen and (orientation:portrait) {
			h1 {
				
			}
			
		
			br.inlandscape {
				display:none;
			}
			
		}
		
		
	</style>
</head>
<body onload="initiation()"> 

<!-- 
//#:PRIME
HTML
-->
	<div class="mainContainer">
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<div>
			<button onclick= "ops.openMain()">Main Menu</button>
		</div>
		<br>
		<br>
		<br>
		<br>
	</div>

	<div id="inputCanvas1" class ="inputCanvas">
		<br>
		<input name="inputProxy" id="inputProxy" value="">
		<p name="description" id="description"></p>
		<button type="button" name="proxySubmit" id="proxySubmit" class="disable-select onCanvas" onclick="drawerOpenClose(); submitInputProxy(); ">Submit ➤</button>
		<br>
		<br>
		<hr class="small">
		<br>
		<button type="button" name="hint" id="hint" class="disable-select onCanvas" onclick="autoEnterProxy();">Show Answer</button>
		<br>
		<br>
		<hr class="small">
		<br>
		<button type="button" name="closeproxy" id="closeproxy" class="disable-select onCanvas" onclick="drawerOpenClose();">Close</button>
	</div>


</body>

<script>
//#:PRIME
//#DECLAIRATIONS


let ws = "";
let srvCart = new Map();
let gameConnected = false;

var outBox = {
	ID: "host",
	player1: [],
	player2: [],
	player3: [],
	player4: [],
	player5: [],
	player6: [],
	player7: [],
	player8: [],
	host: [],
	notice:[],
	set cloneMSG(value){
		this.player1 = value;
		this.player2 = value;
		this.player3 = value;
		this.player4 = value;
		this.player5 = value;
		this.player6 = value;
		this.player7 = value;
		this.player8 = value;
		this.host = value;
		this.notice = [];
	}
};


/*This is the global object that this app primarily serves. This is basically the project and goal. This is the game plan. Here is where it is initiated. 
scenario will have map object as properties. These will have various entries including some deeper nested arrays and map objects.
senario.map1.
⮞These first maps used to plan what will be added to the rotary style game board. Each map entry will define every "slot" around the board.
scenario.map1; // map object at the first level.
⮞The entries inside are called slots. There are a limited number of slots around the physical game board.
There are some standard and limited items that are routinely assigned. First is the key that will also refer to the main card assigned to the slot.
It is because this is really what the slot is based upon that it is both the key assignment, slot name, and an asset that is assigned to it.  This card defines the slot for interaction.
The slot will also have the almost always one slotKit that will be assigned to it. This also is represented by a physical card on the game board. It's purpose is to add more furniture.
Both of these standard entities will bring with the some entities that will have limited editability. I am calling them furniture for now. These include things like "firepit," "wordrobe," and "roof access."
Next are the non-standared entities. These are placed by the crative talent (or lack thereof) of the user. I am not sure yet what I will call that roll. "host" I guess.
Most of these entities are freely editable. They include things like enemies, friendly NPCs, additional funishings, and I am sure I will add other types.
scenario.map1.get("UnthemedPath3"); //These are nested inside the first map objects. scenario.map1.get("UnthemedPath3").get("npc3");
⮞The following depth to our "scenario" nesting scenario is usually all about items and inventory entities. These are more unpredictable as to where they will be found.
Each of the entities represented in the scenario object will be assigned a size that will manage which lists and inventories they can be assigned to. Even when there is not direct property to define the size, it should be assumed.
⮞"transfer"s are entities that will allow some entity to be tranfered from on location to another. Assume one for each size.
There may or may not be one automatically assigned when the locations are generated.
*/
var scenario = {
	saveFile: "currentScenario",
	version: 1,
	map1: {
		"UnthemedPath3": {
			slotKit1: "KitRoom3",
			enemy1: "wolf1",
			npc1: "Joe1"
		}
	},
	map2: {
		"GrassyPlainsPath": {
			slotKit1: "KitRoom3",
			enemy1: "badger1",
			npc1: "Jill1"
		}
	},
	map3: {
		"DryBarrenPath": {
			slotKit1: "KitBeach1",
			enemy1: "scorpion1",
			lootPack: ["Gem", "Sharp Stone"],
			npc1: "Jake1"
		},
		"DryBarrenPath2": {
			slotKit1: "KitBeach1",
			enemy1: "scorpion1",
			lootPack: ["Gem", "Sharp Stone"],
			npc1: "Jake1"
		}
	}
};


//#:PRIME
//# INTERMEDIARY-OBJECT
var ctrl = {
	latestID:0,
	getID: function(){
	ctrl.latestID++;
	return ctrl.latestID;
	},
	targeting: function(event){
	const eventId= event.target.id;
	target = eventId;
	return eventId;
	},
	waiting: false,
	myTimer: function(dir = 1000) {
		if(!ctrl.waiting){
			ctrl.waiting = true;
			setTimeout(ctrl.myTimer, dir);
		}else{
			ctrl.waiting = false;
		};
	},
	change(elementID, text) {
		try{
			const x = document.getElementById(elementID).type;
			x == "number" ? document.getElementsByName(elementID)[0].value = text : document.getElementById(elementID).innerHTML = text;
		}catch(e){
			console.log("Unable for ctrl.change to execute. It may be the element does not exist.");
			return false;
		};
	}
};


























//Stevo's tester. use like this: sr.readElement || sr.readElement = || sr.ct++ || alert(sr.ct) || sr.ct = "testing"; //ect. sr will be console only.
//#:TEST
var  sr =  {
	ct : 0,// I may use console.count()
	history : "Testing",
	set readElement (testObject) {
		sr.ct++;
		const originalElement = event.target || event.srcElement || event.originalTarget;
		const originalTag= event.target.tagName;
		const testObjectType = typeof(testObject);
		const testInfo = {Syntax: "sr.readElement = ", Count: sr.ct, Content:testObject, Type: testObjectType, Element:originalElement, Tag:originalTag};
		console.table({testInfo});
		if(testObjectType == "object")console.table({testObject});
		else if(testObject == "bug")debugger;
		sr.history = testObject;
	},
	get readElement () {
		sr.ct++;
		const originalElement = event.target || event.srcElement || event.originalTarget;
		const originalTag= event.target.tagName;
		const testX = {Syntax: "sr.readElement;", Count: sr.ct, Element:originalElement, Tag:originalTag};
		console.log(testX);
		sr.history = sr.ct;
	},
	stop (content = "") {
		const alerted = {Syntax: "sr.stop;", Count: "unchanged at " + sr.ct, Message:sr.history+" Provided content: "+content};
		console.table({alerted});
		//This could have the ability to give a different result if the sr.stop is called while all alone.
		//if the sr.ct is equal to sr.history then the alert should be "testing" or sr.ct with a description as to why. etc.
		alert(content+" and sr.history: "+sr.history);
	},
	readObj: function(obj){
	//Maybe I can add constructor.name
		let msg = "";
		if(obj instanceof Map){
			console.group("Reading object "+obj+":"); 
			obj.forEach(
				(value, key) => {
					msg = msg +`${key}: ${value}`+ "\n";
				});
		}else{
			for (const [key, value] of Object.entries(obj)) {
				msg = msg +`${key}: ${value}`+ "\n";
			}
		};
		for (const key in window) {
			if (window[key] === obj) {
				console.group("Reading object "+key+":"); 
				break;
			};
		}
		console.info(msg);
		console.table(obj);
		console.groupEnd();
	}
};
	

//#:TESTERS
//#:TEST
function tester(msg){
	console.log("Tester1 was pressed");
};

function tester2(msg){
	console.log("Tester2 was pressed");
};

























//# MIGRATED AND UNREFINED

function initiation(){
	ops.openServiceCart();
}
	
//This is for the starage of variables
function localStorageInitiation () {
	if (localStorage.exists){
		let playerString = localStorage.getItem("sermon");
		//goal = Number(localStorage.goal); // Example
		sermon = JSON.parse(playerString);
	} else {
		//localStorage.setItem("goal", 0); //Example
		localStorage.setItem("exists", true);
		localStorage.setItem("sermon", JSON.stringify(sermon));
	}
}

function prepInputProxy() {
	const currentEntry = document.getElementById(target);
	const parentClause = document.getElementById(currentEntry.parentNode.id).innerText;
	const existingText = currentEntry.innerText;
	const inputBox = document.getElementById("inputProxy");
	document.getElementById("description").innerHTML = parentClause;
	inputBox.value = existingText;
	document.getElementById("inputProxy").focus();
	document.getElementById("inputProxy").select();
}

function autoEnterProxy(targetedText = target){
	const currentEntry = document.getElementById(targetedText);//Parent must have ID.
	const correction = currentEntry.getAttribute("data-correction");
	const inputBox = document.getElementById("inputProxy");
	document.getElementById("inputProxy").blur();
	inputBox.value = correction;
	//document.getElementById(targetedText).innerText = correction;
}

//This will now be to process user input.This should be different from the other button inputs.
function submitInputProxy(targetedText = target) {
const originalElement = event.target || event.srcElement || event.originalTarget;
	var newInput = document.getElementById("inputProxy").value;
	var textToChange = document.getElementById(targetedText).value;
	switch(target) {
		case "specific target":
			break;
		default:
			document.getElementById(targetedText).innerText = newInput;
	}
	//saveToLocalStorage();
}


























//#CONSTRUCTORS
function blankCanvas(cnvClass = "middleTabGlassCanvas",cnvOrient = "V", cnvID = "canvas"+ctrl.getID()){
	this.id = cnvID;
	this.name = cnvID;
	this.class = cnvClass;
	this["data-placement"] = cnvOrient;
	//I would like to have a style class combo to make the look of the div.1 is main and anchor, 2 is the colors.
	//I would like to get the layers to be the z-index rather.
	//The cnvOrient shoudl be obsolete when I make blur animat the way I want. X and them Y, Or Y and then X.
}

function contextMenuLeaf(leafClass = "contextLeaf", leafID = "leaf"+ctrl.getID()){
	this.id = leafID;
	this.name = "context"+leafID;
	this.class = leafClass;
}

function makeButton(text = ctrl.target, btnAct = tester(), btnSize = "medium", btnRound = true, btnDark = true, btnID = "btn"+ctrl.getID()){
	const myColor = btnDark ? "darkText" : "lightText";
	const isRound = btnRound ? "round" : "square";
	const newButton = document.createElement("button");
	newButton.setAttribute("id",btnID);
	newButton.setAttribute("innerHTML",text);
	newButton.setAttribute("textContent",text);
	newButton.setAttribute("name",text);
	newButton.setAttribute("onclick",btnAct);
	newButton.setAttribute("class",`disable-select ${btnSize} ${isRound} ${myColor}`);
	newButton.textContent = text;
	return newButton;
};

function makeBasicLine(lnColor = "light", lnSize = "full"){
	const newLine = document.createElement("hr");
return newLine;
//I will make the usual options here. Like the length and the color.
};

function makeListHeader(text = ctrl.target, txtAct = tester(), txtColor = "inherit", btnDark = true, txtID = "h1"+ctrl.getID()){
const myColor = btnDark ? "darkText" : "lightText";
	const header = document.createElement("h1");
	const textNode = document.createTextNode(text);
	header.appendChild(textNode);
	header.setAttribute("id",txtID);
	header.setAttribute("innerHTML",txtID);
	header.setAttribute("textContent",txtID);
	header.setAttribute("name",txtID);
	header.setAttribute("onclick",txtAct);
	header.setAttribute("style", "color: "+txtColor);
	header.setAttribute("class",`disable-select ${myColor}`);
return header;
};

	//###
	//This is the div that will be representing each list entry and containing the elements that effect the entry.
	function makeListCard(cardTarget = scenario[srvCart.get("selected")], btnAct = `console.warn("List item has no button functions.")`, btnDark = true, entrySize = 0){
		
		
		//Declaring variables and DOM elements.
		let div = document.createElement("div");
		let textLineDiv = document.createElement("div");
		let btnLift = makeButton("Lift", `${btnAct}`, "medium", false, btnDark, "Lift");
		let btnSelect = makeButton("Select", `${btnAct}`, "medium", false, btnDark, "Select");
		let text = document.createElement("p");
		
		div.setAttribute("class","disable-select ");
		div.setAttribute("id",cardTarget);
		div.setAttribute("innerHTML",cardTarget);
		div.setAttribute("textContent",cardTarget);
		div.setAttribute("name",cardTarget);
		text.textContent = entrySize + " " + cardTarget;
		
		//Adding the objects to the div.
		textLineDiv.appendChild(btnLift);
		textLineDiv.appendChild(btnSelect);
		div.appendChild(text);
		div.appendChild(textLineDiv);
		
		return div;
	};

function freshOutBox(value){
	this.ID = "host";
	this.player1 = value;
	this.player2 = value;
	this.player3 = value;
	this.player4 = value;
	this.player5 = value;
	this.player6 = value;
	this.player7 = value;
	this.player8 = value;
	this.host = value;
	this.notice = [];
};

function freshScenario(name = "currentScenario", ver = 1){
	this.saveFile = name;
	this.version = ver;
	this.map1 = [{
		mapSlot: "UnthemedPath",
		slotKit: "none",
		slotAssets: []
	}];
};

























//#:PRIME
//#OPERATIONS
//#OBJECT
var ops = {
	
	//This will soon be depricated as I move building of the canvases are going to be ran by the hmi object.
	close: function(){
		const originalElement = event.target || event.srcElement || event.originalTarget;
		var eventParent = document.getElementById(originalElement.id).parentElement;
		if(true){//see if the canvas exists
			navigate.away(eventParent.id);
			hmi.removeCanvas(eventParent.id);
			console.log("From ops.close: "+eventParent.id);
		};
	},
	
	//This will soon be depricated as I move building of the canvases are going to be ran by the hmi object.
	tuck: function(){
		const originalElement = event.target || event.srcElement || event.originalTarget;
		var eventParent = document.getElementById(originalElement.id).parentElement;
		if(true){//see if the canvas exists
			navigate.away(eventParent.id, "tuck");
			//hmi.removeCanvas(eventParent.id);
			console.log("From ops.tuck: "+eventParent.id);
		};
	},
		
	//This will soon be depricated as I move building of the canvases are going to be ran by the hmi object.
	openMain: function(){
		if(navigate.has("MainMenu")){
			navigate.canvas("MainMenu");
			return;
		};
		hmi.buildCanvas("middleTabGlassCanvas", "V","MainMenu");
		let innerDiv = document.createElement("div");
		const innerDivElements = [
			makeButton("Test1", "tester()", "medium", false, false, "Test1"),
			makeBasicLine(),
			makeButton("Test2", "tester2()", "medium", false, false, "Test2"),
			makeBasicLine(),
			makeButton("Connect", "session.start()", "medium", false, false, "Connect"),
			makeBasicLine(),
			makeButton("Exchange Mail", "session.exchangeCommands()", "medium", false, false, "Exchange"),
			makeBasicLine(),
			makeButton("Save Scenario", "ops.saveScenario()", "medium", false, false, "Save_Scenario"),
			makeBasicLine(),
			makeButton("Load Scenario", "ops.loadScenario()", "medium", false, false, "Load_Scenario"),
			makeBasicLine(),
			makeButton("Map List", "ops.openMapList()", "medium", false, false, "Open_MapList"),
			makeBasicLine(),
			makeButton("Show scenario in console", "sr.readObj(scenario)", "medium", false, false, "Open_MapList"),
			makeBasicLine(),
			makeButton("Show srvCart in console", "sr.readObj(srvCart)", "medium", false, false, "Open_MapList"),
			makeBasicLine()
		]
		innerDiv.setAttribute("id","inner_MainMenu");
		innerDiv.setAttribute("class","innerScroll");
		innerDivElements.forEach((element) => innerDiv.appendChild(element));
		hmi.buildOn(
			"MainMenu",
			makeListHeader("Main Menu", "console.log('Main Menu Header was clicked')", "", false, "MainMenuHeader"),
			innerDiv,
			makeButton("Close", "ops.close()", "medium", false, false, "CloseMain")
		);
		
		//hmi.buildOn("MainMenu", makeButton("Close", "ops.close()", "medium", false, false, "CloseMain"));
		navigate.canvas("MainMenu");
		
	},
	
	//This will soon be depricated as I move building of the canvases are going to be ran by the hmi object.
	openMapList: function(){
		if(navigate.has("MapListCanvas")){
			navigate.canvas("MapListCanvas");
			return;
		};
		hmi.buildCanvas("middleTabGlassCanvas", "V","MapListCanvas");
		let mapList = Object.keys(scenario); 
		mapList.shift();
		mapList.shift();
		let innerDiv = document.createElement("div");
		innerDiv.setAttribute("id","inner_MapMenu");
		innerDiv.setAttribute("class","innerScroll");
		mapList.forEach(
			(element) => {
				innerDiv.appendChild(makeButton(element, `hmi.buildContextLeaf('scenario')`, "medium", false, false, element));
				innerDiv.appendChild(makeBasicLine());
			}
		);
		hmi.buildOn(
			"MapListCanvas", 
			makeListHeader("List Of Maps", "console.log('List Of Maps Header was clicked')", "", false, "MapMenuHeader"),
			innerDiv,
			makeButton("Close", "ops.close()", "medium", false, false, "CloseMapList")
		);
		navigate.canvas("MapListCanvas");
	},
	
	//This will soon be depricated as I move building of the canvases are going to be ran by the hmi object.
	openServiceCart: function(){
		if(navigate.has("serviceCartCanvas")){
			navigate.canvas("serviceCartCanvas");
			return;
		};
		hmi.buildCanvas("serviceCartCanvas tuckVertically", "V","serviceCartCanvas");
		
		let innerDiv = document.createElement("div");
		innerDiv.setAttribute("id","inner_ServiceCart");
		
		srvCart.forEach(
			(v, k) => {
				if(k === "selected")return;
				innerDiv.appendChild(makeButton(k, `console.log("${k} and ${v}")`, "medium", false, true, k));
				innerDiv.appendChild(makeBasicLine());
			}
		);
		//I need to make a custom header button. I need to tuck to fit it too.
		hmi.buildOn(
			"serviceCartCanvas",
			makeListHeader(srvCart.get("selected"), "navigate.serviceCart()", "var(--fontColor1)", true, "ServiceCartSelection"),
			innerDiv,
			makeButton("Close", "ops.tuck()", "medium", false, true, "closeSrvCartCanvas")
		);
		//navigate.canvas("serviceCartCanvas");
	},
	
	saveScenario: function(){
			if(gameConnected)session.mngFiles("saveFile");
	},
	
	loadScenario: function(){
		if(gameConnected)session.mngFiles("loadFile");
	},
	
	scnMapsActions: function(command = "select", path, target){
		//"path" somehow became a programmical reference to the object I sent as a string.
		//console.log("PROBE A "+path.map3.get("UnthemedPath3").get("slotKit")+""+""+""+"");
		//map3: new Map([
			//["UnthemedPath3",new Map([["slotKit","graveKit2"],["npc3",{name:"Joe"}],["foe1",{name:"Wolf"}]])]
		//])
		//path.delete("foe1"); 
		if(!path instanceof Object)return false;
		switch(command){
		case "select":
			break;
		case "rename":
			path instanceof Map ? path.delete(target) : delete path[target];
			break;
		case "delete":
			path instanceof Map ? path.delete(target) : delete path[target];
			break;
		case "lift":
			if(path instanceof Map){ 
				ops.serviceCartActions("add", target, path.get(target));
				path.delete(target);
			}else{
				ops.serviceCartActions("add", target, path[target]);
				
				delete path[target];
				hmi.removeCanvasListElement(target);
				
			};
			
			//ops.serviceCartActions("add", target, path.get(target));
			break;
		case "place":
			const selected = ops.serviceCartActions();
			if(path instanceof Map){ 
				path.set(selected, ops.serviceCartActions("give", selected));
			}else{
				path = ops.serviceCartActions("give", selected);
			};
			break;
		case "stamp":
			
			break;
		default:
		console.log("Defaulted on ops.alterObject()");
		}
		hmi.updateServiceCartHead();
		sr.readObj(scenario);
		sr.readObj(srvCart);
		
	},
	
	serviceCartActions: function(command = "selected?", subject = srvCart.get("selected"), content){
		switch(command){
				case "select":
					srvCart.set("selected", subject);
					break;
				case "add":
					//I may only be getting the content of what I want and not the object that holds them. (drybarrenpath rather than map1)
					//I propose searching and returning the value from the scenario and returning only the property as a new object after it meets the search querry.
					//Rememeber content VS subject
					srvCart.set("selected", subject);
					srvCart.set(subject, content);
					break;
				case "remove":
					srvCart.delete(subject);
					hmi.removeCanvasListElement(subject);
					break;
				case "get":
					srvCart.get(subject);
					break;
				case "give":
					const tempVariable = srvCart.get(subject);
					srvCart.delete(subject);
					hmi.removeCanvasListElement(subject);
					return tempVariable;
					break;
				default:
					return srvCart.get("selected");
			};
		hmi.updateServiceCartHead();
	},
	
	btn: function (preSet){
		try{
			switch(preSet){
				case "Root":
					break;
				case "Test":
					
					break;
				case "Test":
					
					break;
				default:
			};
		}catch(e){
			console.log("hmi.open() coudld not execute. Maybe there was a type in the \"preSet\" argument");
		};
	}
};

























//#NAVIGATE
//#OBJECT
var navigate = {

	has: function(cnvID = "canvas"+ctrl.latestID){
		const hasElement = document.getElementById(cnvID);
		if(hasElement){
			return true;
		}else{
			return false;
		};
	},
	
	//Back will navigate to lower layer and blur the layers above.
	away: function (targetElement, mode = "blur"){
		try{
			if(navigate.here <= 0) throw new Error("Attempting to navigate to <0.");
			const elementID = document.getElementById(targetElement);
			mode == "blur" ? hmi.blur(elementID) : hmi.tuckServiceCart(elementID);//tuck
		}catch(e){
			console.log("navigate.back failed to execute. Maybe the element does not exist. "+e);
		};
	},
	//Navigates to the specified canvas.
	canvas: function (navCNV = "canvas"+ctrl.latestID){
		hmi.focus(navCNV);
	},
	
	//Untucks the service cart
	serviceCart: function (){
		hmi.untuckServiceCart();
	}
	
}

























//#HMI
//#OBJECT
//"hmi" relates to manipulating the screens, hmi, and lists that orientation of the window in this web app.
var hmi = {
	buildOn: function(cnvIDArg = "canvas"+ctrl.latestID){
		let myDiv = cnvIDArg instanceof HTMLElement ? cnvIDArg : document.getElementById(cnvIDArg);
		for (let i = 1; i < arguments.length; i++) {
			myDiv.appendChild(arguments[i]);
		};
	},
	
	//###This was copied here in preperation for definition. 1 of 2 
	addCanvasListElement: function(elementID){
		let lacationForElement = document.getElementById(elementID).parentElement;
		let element = document.getElementById(elementID);
		/*
		//The big problem is that there is a line object , otherwise I would just use the .after() method.
		//button.replaceWith(h2);
		//targetOfLeaf.after(div);
		//innerDiv.appendChild(makeButton(element, `hmi.buildContextLeaf('scenario')`, "medium", false, false, element));
		//innerDiv.appendChild(makeBasicLine());
		//document.getElementById("div-01").nextElementSibling;
		//const eventParent = document.getElementById(originalElement.id).parentElement;
		//hmi.buildOn("");
		//This was an interesting search result.
		//https://www.google.com/search?q=javascript+how+to+get+the+child+number+DOM&rlz=1C1CHBF_enUS825US825&oq=javascript+how+to+get+the+child+number+DOM&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIHCAEQIRigATIHCAIQIRigATIHCAMQIRigATIHCAQQIRigAdIBCjIzNzAxajBqMTWoAgiwAgE&sourceid=chrome&ie=UTF-8
		//https://www.google.com/search?q=javascript+how+to+add+an+element+at+a+child+index+number+DOM&sca_esv=17be21ade0269849&rlz=1C1CHBF_enUS825US825&sxsrf=ADLYWIKK7iKZMHo5N61XoZxPtZRb_I1yzg%3A1723518513074&ei=Mc66Zt2dBNih0PEPs8T7wA0&ved=0ahUKEwid-vDl_vCHAxXYEDQIHTPiHtgQ4dUDCA8&uact=5&oq=javascript+how+to+add+an+element+at+a+child+index+number+DOM&gs_lp=Egxnd3Mtd2l6LXNlcnAiPGphdmFzY3JpcHQgaG93IHRvIGFkZCBhbiBlbGVtZW50IGF0IGEgY2hpbGQgaW5kZXggbnVtYmVyIERPTTIIECEYoAEYwwRI148BUOEGWJWBAXACeACQAQCYAZEBoAHHH6oBBDEuMzS4AQPIAQD4AQGYAh6gAtsZwgIKEAAYsAMY1gQYR8ICChAhGKABGMMEGArCAggQABiiBBiJBcICCBAAGIAEGKIEmAMAiAYBkAYIkgcEMi4yOKAHuIQB&sclient=gws-wiz-serp
		//https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceChildren//This was really cool!
		
		const childElement = document.getElementById("child"); // Get the child element
		const parentElement = childElement.parentNode; // Get the parent element
		const children = Array.from(parentElement.children); // Convert HTMLCollection to array
		const childIndex = children.indexOf(childElement); // Find the index of the child

		console.log(childIndex); // Output the child number (index)
		*/
		if(element instanceof HTMLElement ){
			
		}
		let arrayOfAdds = [];
		myDiv.appendChild(arrayOfAdds);
	},
	
	//This will remove an element.
	removeCanvasListElement: function(elementID){
		var element = document.getElementById(elementID);
		if(element instanceof HTMLElement ){
			element.remove();
		}
	},
	
	
	updateServiceCartHead: function(text = srvCart.get("selected")){
		let head = document.getElementById("ServiceCartSelection");
		head.textContent = text;
	},
	
	buildContextLeaf: function(path){
		//instead of height animation https://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working
		//I need something that will close the leaf if it is already open. This can wait...
		//console.log("at buildConcxtmenu " + typeof path);
		
		//Declaring variables and DOM elements.
		const leafObject = new contextMenuLeaf();
		let div = document.createElement("div");
		let downDiv = document.createElement("div");
		let upDiv = document.createElement("div");
		let emptyDiv = document.createElement("div");
		let edge = document.createElement("img");
		
		//Declaring our target from the event that triggered the context leaf.
		const originalElement = event.target || event.srcElement || event.originalTarget;
		var targetOfLeaf = document.getElementById(originalElement.id);
		
		//Declaing button element variables and setting their onclick events with strings and a literal for passing the address of the scenario object dynamically.
		const target = targetOfLeaf.name;
		let btnLift = makeButton("Lift", "ops.scnMapsActions('lift',"+`${path}`+", '"+target+"')", "medium", false, false, "Lift");
		let btnSelect = makeButton("Select", "ops.scnMapsActions('select',"+`${path}`+", '"+target+"')", "medium", false, false, "Select");
		let btnPlace = makeButton("Place", "ops.scnMapsActions('place',"+`${path}`+", '"+target+"')", "medium", false, true, "Place");
		let btnStamp = makeButton("Stamp", "ops.scnMapsActions('stamp',"+`${path}`+", '"+target+"')", "medium", false, true, "Stamp");
		
		//Setting properties of the potential DOM elements.
		for (let x in leafObject){
			div.setAttribute(x,leafObject[x]);
		};
		edge.src = "roundededge.png";
		upDiv.setAttribute("class","contextLeafTarget");
		downDiv.setAttribute("class","contextLeafLine");
		btnStamp.style.marginTop = "8px";
		btnStamp.style.textShadow = "none";
		btnPlace.style.marginTop = "8px";
		btnPlace.style.textShadow = "none";
		
		
		//Adding the objects to the div.
		upDiv.appendChild(btnLift);
		upDiv.appendChild(btnSelect);
		downDiv.appendChild(btnStamp);
		downDiv.appendChild(btnPlace);
		div.appendChild(downDiv);
		div.appendChild(edge);
		div.appendChild(upDiv);
		
		//Adds the leaf directly after the leaf target.
		targetOfLeaf.after(div);
	},
	
	openMain: function(){
		if(navigate.has("MainMenu")){
			navigate.canvas("MainMenu");
			return;
		};
		hmi.buildCanvas("middleTabGlassCanvas", "V","MainMenu");
		let innerDiv = document.createElement("div");
		const innerDivElements = [
			makeButton("Test1", "tester()", "medium", false, false, "Test1"),
			makeBasicLine(),
			makeButton("Test2", "tester2()", "medium", false, false, "Test2"),
			makeBasicLine(),
			makeButton("Connect", "session.start()", "medium", false, false, "Connect"),
			makeBasicLine(),
			makeButton("Exchange Mail", "session.exchangeCommands()", "medium", false, false, "Exchange"),
			makeBasicLine(),
			makeButton("Save Scenario", "ops.saveScenario()", "medium", false, false, "Save_Scenario"),
			makeBasicLine(),
			makeButton("Load Scenario", "ops.loadScenario()", "medium", false, false, "Load_Scenario"),
			makeBasicLine(),
			makeButton("Map List", "ops.openMapList()", "medium", false, false, "Open_MapList"),
			makeBasicLine(),
			makeButton("Show scenario in console", "sr.readObj(scenario)", "medium", false, false, "Open_MapList"),
			makeBasicLine(),
			makeButton("Show srvCart in console", "sr.readObj(srvCart)", "medium", false, false, "Open_MapList"),
			makeBasicLine()
		]
		innerDiv.setAttribute("id","inner_MainMenu");
		innerDiv.setAttribute("class","innerScroll");
		innerDivElements.forEach((element) => innerDiv.appendChild(element));
		hmi.buildOn(
			"MainMenu",
			makeListHeader("Main Menu", "console.log('Main Menu Header was clicked')", "", false, "MainMenuHeader"),
			innerDiv,
			makeButton("Close", "ops.close()", "medium", false, false, "CloseMain")
		);
		
		//hmi.buildOn("MainMenu", makeButton("Close", "ops.close()", "medium", false, false, "CloseMain"));
		navigate.canvas("MainMenu");
		
	},
	
	openMapList: function(){
		if(navigate.has("MapListCanvas")){
			navigate.canvas("MapListCanvas");
			return;
		};
		hmi.buildCanvas("middleTabGlassCanvas", "V","MapListCanvas");
		let mapList = Object.keys(scenario); 
		mapList.shift();
		mapList.shift();
		let innerDiv = document.createElement("div");
		innerDiv.setAttribute("id","inner_MapMenu");
		innerDiv.setAttribute("class","innerScroll");
		mapList.forEach(
			(element) => {
				innerDiv.appendChild(makeListCard(element, `hmi.buildContextLeaf('scenario')`, false, 3));
			}
		);
		hmi.buildOn(
			"MapListCanvas", 
			makeListHeader("List Of Maps", "console.log('List Of Maps Header was clicked')", "", false, "MapMenuHeader"),
			innerDiv,
			makeButton("Close", "ops.close()", "medium", false, false, "CloseMapList")
		);
		navigate.canvas("MapListCanvas");
	},
	
	openServiceCart: function(){
		if(navigate.has("serviceCartCanvas")){
			navigate.canvas("serviceCartCanvas");
			return;
		};
		hmi.buildCanvas("serviceCartCanvas tuckVertically", "V","serviceCartCanvas");
		
		let innerDiv = document.createElement("div");
		innerDiv.setAttribute("id","inner_ServiceCart");
		
		srvCart.forEach(
			(v, k) => {
				if(k === "selected")return;
				innerDiv.appendChild(makeButton(k, `console.log("${k} and ${v}")`, "medium", false, true, k));
				innerDiv.appendChild(makeBasicLine());
			}
		);
		//I need to make a custom header button. I need to tuck to fit it too.
		hmi.buildOn(
			"serviceCartCanvas",
			makeListHeader(srvCart.get("selected"), "navigate.serviceCart()", "var(--fontColor1)", true, "ServiceCartSelection"),
			innerDiv,
			makeButton("Close", "ops.tuck()", "medium", false, true, "closeSrvCartCanvas")
		);
		//navigate.canvas("serviceCartCanvas");
	},
	
	//Brings the canvas into view. Submissive to the navigate object.
	focus: async function(cnvID = "canvas"+ctrl.latestID){
		try{
			var element = document.getElementById(cnvID);
			console.log("this is focus hmi : "+cnvID);
			let actions = function(){
				if(element.getAttribute("data-placement") == "V"){
					element.classList.remove("closeVertically");
					element.classList.remove("tuckVertically");
					element.classList.add("openVertically"); 
				}else{
					element.classList.remove("closeHorizontally");
					element.classList.remove("tuckHorizontally");
					element.classList.add("openHorizontally"); 
				};
			};
			if(ctrl.waiting){
				let myPromise = new Promise(function(resolve) {
					setTimeout(function() {
						resolve(actions());
					}, 0);
				});
				
			}else{
				actions();
			};
		}catch(e){
			console.log("HMI failed to focus.");
		}
	},
	
	untuckServiceCart: async function(cnvID = "canvas"+ctrl.latestID){
		try{
			var element = document.getElementById("serviceCartCanvas");
			let actions = function(){
				element.classList.remove("tuckVertically");
				element.classList.add("untuckServiceCart");
			};
			if(ctrl.waiting){
				let myPromise = new Promise(function(resolve) {
					setTimeout(function() {
						resolve(actions());
					}, 0);
				});
				
			}else{
				actions();
			};
		}catch(e){
			console.log("HMI failed to untuck the service cart.");
		}
	},
	
	//Hides the canvas from view. Submissive to the navigate object.
	blur: function(cnvIDArg = "canvas"+ctrl.latestID){
		const cnvID = cnvIDArg instanceof Object ? cnvIDArg.id : cnvIDArg;
		try{
			var element = document.getElementById(cnvID);
			if(element.getAttribute("data-placement") == "V"){
				element.classList.remove("openVertically");
				element.classList.add("closeVertically"); 
			}else{
				element.classList.remove("openHorizontally");
				element.classList.add("closeHorizontally"); 
			};
		}catch(e){
			console.log("The element "+cnvID+" does not exist");
			return;
		};
		ctrl.myTimer(10);
		
	},
	
	//Hides the canvas from view mostly. Submissive to the navigate object.
	tuck: function(cnvIDArg = "canvas"+ctrl.latestID){
		const cnvID = cnvIDArg instanceof Object ? cnvIDArg.id : cnvIDArg;
		try{
			let element = document.getElementById(cnvID);
			if(element.getAttribute("data-placement") == "V"){
				element.classList.remove("openVertically");
				element.classList.add("tuckVertically"); 
			}else{
				element.classList.remove("openHorizontally");
				element.classList.add("tuckHorizontally"); 
			};
		}catch(e){
			console.log("The element does not exist");
			return;
		};
		ctrl.myTimer(10);
		
	},
	
	tuckServiceCart: function(){
		const element = document.getElementById("serviceCartCanvas");
		element.classList.remove("openVertically");
		element.classList.remove("untuckServiceCart");
		element.classList.add("tuckVertically"); 
	},
		
	//Creates canvas' (div elements) but does not make them visable. 
	buildCanvas: function(cnvClass = "middleTabGlassCanvas",cnvOrient = "V", cnvID = "canvas"+ctrl.getID()){
		let tempCanvas = new blankCanvas(cnvClass,cnvOrient, cnvID);
		let div = document.createElement("div");
		for (let x in tempCanvas){
			div.setAttribute(x,tempCanvas[x]);
		};
		if(true){//Condition to ensure there are no duplicate errors.
			document.body.appendChild(div);
			ctrl.myTimer(10);
		}
	},
	
	
	//Removes canvases (div elements) but does not hide them first. It will wait on hmi.blur close animation. This will not navigate automatically.
	removeCanvas: async function(cnvID = "canvas"+ctrl.latestID){
		try{
			var element = document.getElementById(cnvID);
			const cnvLay = Number(element.getAttribute("data-layer"));
			if(ctrl.waiting){
				let myPromise = new Promise(function(resolve) {
					setTimeout(function() {
						resolve(element.remove());
					}, 400);
				});
			}else{
				element.remove();
			};
		}catch(e){
			console.log("The element does not exist");
			return;
		};
	}	
}


























//This was moved to top of page
//var content = [{c:""}];//Considering leaving this in the Global scope for an undo function and a history.
//"game" will be use for functions that have to do with the game of course. Some of the functions are only related to the players web apps.
//#GAME
//#OBJECT
var game = {
	cmdTest: "game.cmdTest = Success",
	command: {
		cmdTest: "game.command.cmdTest = Success!",
		cmdIDAssign:function(content){outBox.ID = content},
		cmdAlert: function(content){alert(content)},
		cmdSendNotice: function(content){outBox.notice = content},
		cmdLoadScenario: function(content) {
			if(gameConnected){;
				console.log("Sending probe1");
				const testObj = {loadFile:"Tusk",version:1};
				ws.send(JSON.stringify(testObj));
			};
			alert(content);
		}
		
	},
	info: {
		infoTest: "game.info.infoTest = Success"
	}
};

























//#SESSION
//#OBJECT
var session = { 
	start: function(){
		//https://piehost.com/websocket/how-to-build-websocket-server-and-client-in-nodejs
		
		/*
		When testing we are only using the local host.
		ws = new WebSocket("ws://localhost:8080");
		*/
		//This is my IP for my PC. We can add a IP input option later.
		ws = new WebSocket("ws://192.168.88.253:8080");
		ws.addEventListener("open", () =>{
			console.log("We are connected");
			gameConnected = true;
		});
		ws.addEventListener('message', function (event) {
			session.handleMessage(event.data);
		});
		ws.addEventListener('error', function (event) {
			gameConnected = false;
			alert("Unable to connect to the websocket server on port: 8080");
		});
		ws.addEventListener('close', function (event) {
			gameConnected = false;
			console.log("Host disconnected");
		});
	},
	
	//This is where function will identify the message and route it.
	handleMessage: function(msg = "{}"){
		var parsedObject = {};//{"notice": []};
		var itentifier = "";
		try {
			parsedObject = JSON.parse(msg);
			const sampleSample = Array.isArray(parsedObject) ? parsedObject[0] : parsedObject;//Pull sampl from an array
			const sample = Array.isArray(sampleSample) ? sampleSample[0] : sampleSample;//Check for nesting
			//console.log(parsedObject);
			//Pulling an identifier from the sample.
			if(typeof sample === "string" || typeof sample === "number"){
				itentifier = sample;
			}else{
				itentifier = Object.keys(sample)[0];
			};
			//Direction based on identifier.
			if(itentifier.startsWith("cmd")){
				console.log("Received a session command");
				session.cmdExecute(parsedObject);//This will eventually be used in the game.command.
			}else if(itentifier.includes("json")||itentifier.includes("JSON")){
				console.log("Received a List of JSON from the root directory");
				return parsedObject;//This will return a list of the availible files that can be loaded.
			}else if(itentifier.includes("saveFile")){
				console.log("Received a saveFile [and added it to scenario]");
				scenario = { ...parsedObject};
				sr.readObj(scenario);
			}else{
				console.log("handleMessage() could not identify the message content starting with "+itentifier);
			};
		}catch(e){//Handle parse errors
			if(Array.isArray(msg)){
				console.log("Found an array at handleMessage() that could not be parsed as a JSON.");
				msg.forEach(function(item, index){ 
					console.log(item); 
				})
			}else{
				console.log("Message received at \"handleMessage()\"\t\""+msg+"\"\t session.handleMessage() was not able to parse the message as a JSON.");
			};
		}
	},
	
	exchangeCommands: function(){
		const myJSON = JSON.stringify(outBox);
		if(gameConnected) ws.send(myJSON);
		console.log("The pending messages have been sent to the websocket server.");
		outBox = new freshOutBox([]);
	},
	
	cmdExecute: function(msg = {}){
		if(Array.isArray(msg)){//msg is an array
			for (var i = 0; i < msg.length; i++) {
				try{
					for (let x in msg[i]){
						const propertyValue = msg[i][x];
						game.command[x](propertyValue);
					}
				}catch(e){//this element in the array is not an object
				}
				console.log("session.cmdExecute() ran an array but this element was not an object.");
			}
		}else{//msg is NOT an array
			try{
				for (let x in msg){
					game.command[x](msg[x]);
				}
			}catch(e){//msg is NOT an object
				console.log("Message received at session.cmdExecute() \""+msg+"\". This message could not be parsed as commands.");
			}
		}
		console.table(outBox);
	},
	
	/*
	I am using alot of map objects and will need to convert them so that they can be saved as JSON files. I plan to put this in ops with calls to ctrl.
	This method involves converting the Map into an array of key-value pairs using Array. from() or spreading (…) the Map, 
	then using Object. fromEntries() to convert this array back into an object, followed by JSON. stringify() to convert the object to JSON.
	*/
	mngFiles: function(act = 0, fileName = scenario.saveFile, ver = scenario.version, definedObj = scenario){
		let prepObject = {};
		let action = act === 0 ? "saveFile" : act === 1 ? "loadFile" : act === 2 ? "deleteFile" : act === 3 ? "dirList" : act;
		if(action == "saveFile"){
			prepObject = definedObj;
		}else{
			prepObject = Object.fromEntries([[action, fileName], ["version", ver]]);
		}
		if(gameConnected){
			ws.send(JSON.stringify(prepObject));
		};
	}
}

/*

//Used if the touch events for phones and tablets do not work. This will need to be moved above teh HTML
	function isTouch() {
	{
		try{ document.createEvent("TouchEvent"); return true; }
		catch(e){ return false; }
	}
		if(isTouch()){
			$(document).ready(
				function(){
					$("button").on('touchstart',function(){
						//The bellow function was renamed for another purpose. I was wondering iff I even need this jquery but I will know more after I try using a touchscreen.
						//If that happens then I will need to reinstate the buttonHandler().
						buttonHandler(this.id, this.name);
					});
				}
			);
		}else{
			$(document).ready(
				function(){
					$("button").mousedown(function(){
						buttonHandler(this.id, this.name);
					});
				}
			);
		}
	}



//https://dev.to/__khojiakbar__/map-in-js-59k6
From w3:		array.map(function(currentValue, index, arr), thisValue) // Function can be anything. Combine with .set(arg,arg) and .get(arg)

let funnyMap = new Map(); 

funnyMap.set('a', 1); // string key
funnyMap.set(2, 'two'); // number key
funnyMap.set(true, 'yes'); // boolean key
funnyMap.set({name: 'obj'}, 'object'); // object key
funnyMap.set('knock-knock', "who’s there?"); // string key

console.log(funnyMap.get('a')); // 1
console.log(funnyMap.get(2)); // two
console.log(funnyMap.get(true)); // yes

// Funny example
console.log(funnyMap.get('knock-knock')); // who’s there?

// Iterating over entries
for (let [key, value] of funnyMap.entries()) {
console.log(`Key: ${key}, Value: ${value}`);
}
	*/
	
























</script>
</html>
